{
  "array_item_remove_end_mutable": {
    "prefix": [
      "aer",
      "item_remove_from_array_end_mutable"
    ],
    "description": "\nconst ${2:last} = ${1:arr}.pop()\n",
    "body": [
      "const ${2:last} = ${1:arr}.pop()"
    ]
  },
  "array_item_remove_first_immutable": {
    "prefix": [
      "afri",
      "item_remove_from_array_first_immutable"
    ],
    "description": "\nconst [first,...${2:rest}] = ${1:arr}\n",
    "body": [
      "const [first,...${2:rest}] = ${1:arr}"
    ]
  },
  "array_item_remove_first_mutable": {
    "prefix": [
      "afr",
      "item_remove_from_array_first_mutable"
    ],
    "description": "\nconst ${2:first} = ${1:arr}.shift()\n",
    "body": [
      "const ${2:first} = ${1:arr}.shift()"
    ]
  },
  "array_item_remove_immutable": {
    "prefix": [
      "ari",
      "item_remove_from_array_immutable"
    ],
    "description": "\n  ${1:arr} = ${1:arr}.filter((item)=>${2:item.id === id})\n",
    "body": [
      "${1:arr} = ${1:arr}.filter((item)=>${2:item.id === id})"
    ]
  },
  "array_item_remove_mutable": {
    "prefix": [
      "arm",
      "item_remove_from_array_mutable"
    ],
    "description": "\n  const index = ${1:arr}.findIndex((item)=>{item.${2:id}===${2:id}})\n  if(index > -1){\n    ${1:arr}.splice(index, 1)\n  }\n",
    "body": [
      "const index = ${1:arr}.findIndex((item)=>{item.${2:id}===${2:id}})",
      "  if(index > -1){",
      "    ${1:arr}.splice(index, 1)",
      "  }"
    ]
  },
  "array1to10": {
    "prefix": [
      "!ten"
    ],
    "description": "\n  [...new Array(10).keys()].map(i=>i+1)\n",
    "body": [
      "[...new Array(10).keys()].map(i=>i+1)"
    ]
  },
  "arrow_function_named": {
    "prefix": [
      "afn"
    ],
    "description": "箭头函数",
    "body": [
      "",
      "const ${1:func} = ($2) => { ",
      "  $3",
      "}"
    ]
  },
  "arrow_function": {
    "prefix": [
      "anfn"
    ],
    "description": "箭头函数",
    "body": [
      "($1) => { ",
      "  $2 ",
      "}"
    ]
  },
  "axios_instance": {
    "prefix": [
      "!axios"
    ],
    "description": "axios 实例",
    "body": [
      "import axios from \"axios\";",
      "const options = {",
      "  baseUrl: \"/\",",
      "  timeout: 10 * 1000,",
      "  headers: {",
      "    Accept: \"application/json\",",
      "    \"Content-Type\": \"application/json\",",
      "  },",
      "};",
      "const instance = axios.create(options);"
    ]
  },
  "Capitalize": {
    "prefix": [
      "Capitalize"
    ],
    "description": "\nfunction capitalize(str){\n  const [first,...rest] = str\n  if(!first) return ''\n  return first.toUpperCase()+ rest.join('').toLowerCase()\n}\n",
    "body": [
      "function capitalize(str){",
      "  const [first,...rest] = str",
      "  if(!first) return ''",
      "  return first.toUpperCase()+ rest.join('').toLowerCase()",
      "}"
    ]
  },
  "class_enum": {
    "prefix": [
      "!enum"
    ],
    "description": "\nclass $1 {\n  // Create new instances of the same class as static attributes\n  static $2 = new $1(\"$2\")\n  static $3= new $1(\"$3\")\n\n  constructor(name) {\n    this.name = name\n  }\n}\n",
    "body": [
      "class $1 {",
      "  // Create new instances of the same class as static attributes",
      "  static $2 = new $1(\"$2\")",
      "  static $3= new $1(\"$3\")",
      "",
      "  constructor(name) {",
      "    this.name = name",
      "  }",
      "}"
    ]
  },
  "commonjs_exec_exe_file": {
    "prefix": [
      "exe"
    ],
    "description": "使用 nodejs 执行exe文件",
    "body": [
      "const { execFile } = require(\"child_process\");",
      "const command = `$1.exe`",
      "execFile(command, function (err, data) {",
      "  console.log(err);",
      "  console.log(data.toString());",
      "});"
    ]
  },
  "commonjs_exec": {
    "prefix": [
      "exec"
    ],
    "description": "使用 nodejs 执行某个命令",
    "body": [
      "const { exec } = require(\"child_process\");",
      "const command = `$1`",
      "exec(command, (err, stdout, stderr) => {",
      "  if (err) {",
      "    console.error(err);",
      "    return;",
      "  }",
      "  console.log(stdout);",
      "});"
    ]
  },
  "commonjs_spawn": {
    "prefix": [
      "spawnexe"
    ],
    "description": "使用 nodejs spawn 执行命令",
    "body": [
      "const { spawn } = require(\"child_process\");",
      "const [command,...args] = `$1`.split(\" \");",
      "const child = spawn(command,args,{stdio:\"inherit\"});",
      "child.stdout.on('data', (data) => {",
      "  console.log(data.toString());",
      "});",
      "",
      "child.stderr.on('data', (data) => {",
      "  console.error(data.toString());",
      "});",
      "",
      "child.on('exit', (code) => {",
      "  console.log(`Child exited with code ${code}`);",
      "});",
      "child.on(\"error\", (err) => {})",
      "child.on(\"close\", () => {})"
    ]
  },
  "console_log": {
    "prefix": [
      "csl",
      "logg"
    ],
    "description": "console.log(*)",
    "body": [
      "console.log(`$1`,$1)"
    ]
  },
  "date_version": {
    "prefix": [
      "!tv"
    ],
    "body": [
      "\"$CURRENT_YEAR.$CURRENT_MONTH.$CURRENT_DATE\""
    ],
    "description": "今天日期"
  },
  "debounce": {
    "prefix": [
      "debounce"
    ],
    "description": "\nconst debounce = (fn, delay, immediate)=> {\n  let timer\n  let result\n  return function(...args) {\n    if (timer) clearTimeout(timer)\n\n    if (immediate) {\n      // 如果timer存在，说明第二次调用的时候还没到delay时间，因为如果超过delay时间\n      // timer会被赋值为null，所以这个时候我们不应该执行fn，应该重新设置一个定时器\n      // 但如果是一次的时候，因为还没有设过定时器，所以这里timer会是undefined\n      if (timer) {\n        timer = setTimeout(() => timer = null, delay)\n      } else {\n        result = fn.apply(this, args)\n        return result\n      }\n    } else {\n      timer = setTimeout(() => fn.apply(this, args), delay)\n    }\n  }\n}\n\n",
    "body": [
      "const debounce = (fn, delay, immediate)=> {",
      "  let timer",
      "  let result",
      "  return function(...args) {",
      "    if (timer) clearTimeout(timer)",
      "",
      "    if (immediate) {",
      "      // 如果timer存在，说明第二次调用的时候还没到delay时间，因为如果超过delay时间",
      "      // timer会被赋值为null，所以这个时候我们不应该执行fn，应该重新设置一个定时器",
      "      // 但如果是一次的时候，因为还没有设过定时器，所以这里timer会是undefined",
      "      if (timer) {",
      "        timer = setTimeout(() => timer = null, delay)",
      "      } else {",
      "        result = fn.apply(this, args)",
      "        return result",
      "      }",
      "    } else {",
      "      timer = setTimeout(() => fn.apply(this, args), delay)",
      "    }",
      "  }",
      "}"
    ]
  },
  "delay": {
    "prefix": [
      "wait",
      "delay"
    ],
    "description": "\nconst timeout = ${1:1000}\nawait new Promise((resolve) => setTimeout(resolve, timeout))\n",
    "body": [
      "const timeout = ${1:1000}",
      "await new Promise((resolve) => setTimeout(resolve, timeout))"
    ]
  },
  "esmodule__dirname": {
    "prefix": [
      "!dirname"
    ],
    "description": "import { fileURLToPath } from 'url';\nimport { dirname } from 'path';\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);",
    "body": [
      "import { fileURLToPath } from 'url';",
      "import { dirname } from 'path';",
      "const __filename = fileURLToPath(import.meta.url);",
      "const __dirname = dirname(__filename);"
    ]
  },
  "esmodule__filename": {
    "prefix": [
      "!filename"
    ],
    "description": "import { fileURLToPath } from 'url';\nimport { dirname } from 'path';\nconst __filename = fileURLToPath(import.meta.url);",
    "body": [
      "import { fileURLToPath } from 'url';",
      "import { dirname } from 'path';",
      "const __filename = fileURLToPath(import.meta.url);"
    ]
  },
  "expect_output": {
    "prefix": [
      "expect",
      "//-"
    ],
    "description": "\n// -> $1\n",
    "body": [
      "// -> $1"
    ]
  },
  "ffmpeg_to_mp4": {
    "prefix": [
      "tomp4"
    ],
    "description": "\n  ffmpeg -acodec aac -filter_complex amix=inputs=2:duration=longest -vcodec copy -movflags faststart+frag_keyframe+separate_moof+omit_tfhd_offset+empty_moov\n",
    "body": [
      "ffmpeg -acodec aac -filter_complex amix=inputs=2:duration=longest -vcodec copy -movflags faststart+frag_keyframe+separate_moof+omit_tfhd_offset+empty_moov"
    ]
  },
  "file_header": {
    "prefix": [
      "!fh"
    ],
    "description": "\n/**\n * @author\n * @file $TM_FILENAME\n * @fileBase ${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}\n * @path $RELATIVE_FILEPATH\n * @from \n * @desc $2\n * @todo\n\n *\n * @done\n * @example\n */\n",
    "origin": "\n/**\n * @author\n * @file $TM_FILENAME\n * @fileBase ${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}\n * @path $RELATIVE_FILEPATH\n * @from \n * @desc $2\n * @todo\n\n *\n * @done\n * @example\n */\n",
    "body": [
      "/**",
      " * @author",
      " * @file $TM_FILENAME",
      " * @fileBase ${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}",
      " * @path $RELATIVE_FILEPATH",
      " * @from ",
      " * @desc $2",
      " * @todo",
      "",
      " *",
      " * @done",
      " * @example",
      " */"
    ]
  },
  "file_name": {
    "prefix": [
      "!file_name"
    ],
    "description": "${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}",
    "origin": "${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}",
    "body": [
      "${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}"
    ]
  },
  "get_now_dayjs": {
    "prefix": [
      "gnow"
    ],
    "description": "function getNow() {\n  return dayjs().format(\"YYYY-MM-DD dddd HH:mm:ss\");\n}",
    "body": [
      "function getNow() {",
      "  return dayjs().format(\"YYYY-MM-DD dddd HH:mm:ss\");",
      "}"
    ]
  },
  "immediately_async_function": {
    "prefix": [
      "!async",
      "iaf"
    ],
    "description": "\n(${2:async} () => {\n  $1\n})();\n",
    "body": [
      "(${2:async} () => {",
      "  $1",
      "})();"
    ]
  },
  "immediately_function": {
    "prefix": [
      "!if",
      "if"
    ],
    "description": "\n(() => {\n  $1\n})();\n",
    "body": [
      "(() => {",
      "  $1",
      "})();"
    ]
  },
  "method_header": {
    "prefix": [
      "!mh",
      "!funh"
    ],
    "description": "\n/**\n * @method $1\n * @param {} \n * @returns {}\n * @desc $2\n * @example\n */\n",
    "body": [
      "/**",
      " * @method $1",
      " * @param {} ",
      " * @returns {}",
      " * @desc $2",
      " * @example",
      " */"
    ]
  },
  "mobx_class_store": {
    "prefix": [
      "!mobxclass"
    ],
    "description": "\nimport { action, observable } from 'mobx';\n\nclass Store {\n    @observable\n    count = 1;\n    \n    @action\n    setCount = () => {\n        this.count++;\n    }\n}\nexport const store = new Store();\n\n",
    "body": [
      "import { action, observable } from 'mobx';",
      "",
      "class Store {",
      "    @observable",
      "    count = 1;",
      "    ",
      "    @action",
      "    setCount = () => {",
      "        this.count++;",
      "    }",
      "}",
      "export const store = new Store();"
    ]
  },
  "mobx_store": {
    "prefix": [
      "!mobx"
    ],
    "description": "\nimport {observable, action} from 'mobx';\nconst store = observable(\n  {\n    value: 0,\n    setValue(value) {\n      this.value = value;\n    },\n  },\n  {\n    setValue:action\n  }\n);\n\nexport default store;\n\n",
    "body": [
      "import {observable, action} from 'mobx';",
      "const store = observable(",
      "  {",
      "    value: 0,",
      "    setValue(value) {",
      "      this.value = value;",
      "    },",
      "  },",
      "  {",
      "    setValue:action",
      "  }",
      ");",
      "",
      "export default store;"
    ]
  },
  "node_bin": {
    "prefix": [
      "!node",
      "!nb"
    ],
    "description": "\n#!/usr/bin/env node\n",
    "body": [
      "#!/usr/bin/env node"
    ]
  },
  "now": {
    "prefix": [
      "now",
      "!now"
    ],
    "body": [
      "\"$CURRENT_YEAR年$CURRENT_MONTH月$CURRENT_DATE日 $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\""
    ],
    "description": "当前时间"
  },
  "object_entries_foreach": {
    "prefix": [
      "oef"
    ],
    "description": "Object.entries(options).forEach(([key,value])=>{\n$1\n}",
    "body": [
      "Object.entries(options).forEach(([key,value])=>{",
      "$1",
      "}"
    ]
  },
  "object_get_by_path_lodash": {
    "prefix": [
      "lg",
      "ogpl"
    ],
    "description": "\nimport {get} from 'lodash-es'\nget(obj, path,defaultValue)\n",
    "body": [
      "import {get} from 'lodash-es'",
      "get(obj, path,defaultValue)"
    ]
  },
  "object_mergeRight": {
    "prefix": [
      "mergeRight"
    ],
    "description": "\n  function mergeRight(obj, theOtherObj){\n    return \n  }\n",
    "body": [
      "function mergeRight(obj, theOtherObj){",
      "    return ",
      "  }"
    ]
  },
  "object_set_by_path_lodash": {
    "prefix": [
      "ls",
      "ospl"
    ],
    "description": "\nimport {set} from 'lodash-es'\nset(obj, path, value)\n",
    "body": [
      "import {set} from 'lodash-es'",
      "set(obj, path, value)"
    ]
  },
  "one_line_comment_close": {
    "prefix": [
      "//",
      "ccc"
    ],
    "description": "/** ******  ****** */",
    "body": [
      "${BLOCK_COMMENT_START}* ****** $1 ****** ${BLOCK_COMMENT_END}"
    ]
  },
  "one_line_comment": {
    "prefix": [
      "///"
    ],
    "description": "\n${LINE_COMMENT} ****** $1 ******\n",
    "body": [
      "${LINE_COMMENT} ****** $1 ******"
    ]
  },
  "promise": {
    "prefix": [
      "!promise"
    ],
    "description": "\nnew Promise((resolve,reject)=>{\n  $1\n})\n",
    "body": [
      "new Promise((resolve,reject)=>{",
      "  $1",
      "})"
    ]
  },
  "random_color_value": {
    "prefix": [
      "color"
    ],
    "description": "\nconst color = `#${(~~(Math.random() * (1 << 24))).toString(16)}`\n",
    "body": [
      "const color = `#${(~~(Math.random() * (1 << 24))).toString(16)}`"
    ]
  },
  "react_func_component": {
    "prefix": [
      "!react"
    ],
    "description": "react 函数组件",
    "body": [
      "/**",
      " * @author",
      " * @file $TM_FILENAME",
      " * @fileBase ${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}",
      " * @path $RELATIVE_FILEPATH",
      " * @from ",
      " * @desc $2",
      " * @todo",
      "",
      " *",
      " * @done",
      " * @example",
      " */",
      "",
      "import React, { useState, useEffect, memo } from 'react'",
      "",
      "function ${1:${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}}() {",
      "  return (",
      "    <div>",
      "      ${1:${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}}",
      "    </div>",
      "  )",
      "}",
      "",
      "export default ${1:${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}}"
    ]
  },
  "react_hook": {
    "prefix": [
      "!hook"
    ],
    "description": "\n/**\n * @author\n * @file $TM_FILENAME\n * @fileBase ${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}\n * @path $RELATIVE_FILEPATH\n * @from \n * @desc $2\n * @todo\n\n *\n * @done\n * @example\n */\n\nimport { useState, useEffect } from \"react\";\n// import { useDispatch } from \"react-redux\";\n\nexport default function ${1:${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}}() {\n  const [$2] = useState(null);\n  return {$2};\n}\n\n",
    "body": [
      "/**",
      " * @author",
      " * @file $TM_FILENAME",
      " * @fileBase ${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}",
      " * @path $RELATIVE_FILEPATH",
      " * @from ",
      " * @desc $2",
      " * @todo",
      "",
      " *",
      " * @done",
      " * @example",
      " */",
      "",
      "import { useState, useEffect } from \"react\";",
      "// import { useDispatch } from \"react-redux\";",
      "",
      "export default function ${1:${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}}() {",
      "  const [$2] = useState(null);",
      "  return {$2};",
      "}"
    ]
  },
  "react_import": {
    "prefix": [
      "ireact"
    ],
    "description": "\nimport React from 'react';\n",
    "body": [
      "import React from 'react';"
    ]
  },
  "reactnative_flat_list": {
    "prefix": [
      "!flatlist"
    ],
    "description": "react_flat_list",
    "body": [
      "(",
      "  <FlatList",
      "      data={$data}",
      "      keyExtractor={(item, index) => index}",
      "      renderItem={({ item }) => (",
      "        <>",
      "          $2",
      "        </>",
      "      )}",
      "    />",
      ")"
    ]
  },
  "reactnative_func_component": {
    "prefix": [
      "!rn"
    ],
    "description": "\n/**\n * @author\n * @file $TM_FILENAME\n * @fileBase ${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}\n * @path $RELATIVE_FILEPATH\n * @from \n * @desc $2\n * @todo\n\n *\n * @done\n * @example\n */\n\nimport React, { useState, useEffect, memo } from 'react'\nimport { View, Text } from 'react-native'\n\nfunction ${1:${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}}() {\n  return (\n    <View>\n      <Text>${1:${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}}</Text>\n    </View>\n  )\n}\n\nexport default ${1:${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}}\n\n",
    "body": [
      "/**",
      " * @author",
      " * @file $TM_FILENAME",
      " * @fileBase ${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}",
      " * @path $RELATIVE_FILEPATH",
      " * @from ",
      " * @desc $2",
      " * @todo",
      "",
      " *",
      " * @done",
      " * @example",
      " */",
      "",
      "import React, { useState, useEffect, memo } from 'react'",
      "import { View, Text } from 'react-native'",
      "",
      "function ${1:${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}}() {",
      "  return (",
      "    <View>",
      "      <Text>${1:${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}}</Text>",
      "    </View>",
      "  )",
      "}",
      "",
      "export default ${1:${RELATIVE_FILEPATH/.*[\\\\|\\/](.*)[\\\\|\\/]index\\..*|.*[\\\\|\\/](.*)\\..*|(.*)\\..*/$1$2$3/}}"
    ]
  },
  "reactnative_section_list": {
    "prefix": [
      "!sectionlist"
    ],
    "description": "react native sectionlist",
    "body": [
      "(",
      "  <SectionList",
      "    flex={1}",
      "    sections={data}",
      "    keyExtractor={(item, index) => index}",
      "    ItemSeparatorComponent={ItemSeparatorComponent}",
      "    renderItem={renderItem || (({ item }) => <SectionItem item={item} onPress={item?.onPress} />)}",
      "    renderSectionHeader={renderHeader || (({ section }) => <SectionHeader title={section.title} />)}",
      "  />",
      ")"
    ]
  },
  "readable": {
    "prefix": [
      "!readable"
    ],
    "description": "\nconst { Readable } = require(\"stream\");\n\nconst readableStream = new Readable({\n  // highWaterMark: \n  read: (size) => {},\n});\n// readableStream.push(\"test\");\n",
    "body": [
      "const { Readable } = require(\"stream\");",
      "",
      "const readableStream = new Readable({",
      "  // highWaterMark: ",
      "  read: (size) => {},",
      "});",
      "// readableStream.push(\"test\");"
    ]
  },
  "redux_toolkit_slice": {
    "prefix": [
      "!slice"
    ],
    "description": "\nimport { createSlice } from \"@reduxjs/toolkit\";\n\n/**\n * 初始state\n */\nconst initialState = {\n  value,\n};\n\nexport const ${1:name}Slice = createSlice({\n  name: \"${1:name}\",\n  initialState,\n  reducers: {\n    setValue(state,{payload}) {\n      \n    }\n  },\n});\n// Action creators are generated for each case reducer function\nexport const {\n  setValue\n} = ${1:name}Slice.actions;\n\nexport default ${1:name}Slice.reducer;\n",
    "body": [
      "import { createSlice } from \"@reduxjs/toolkit\";",
      "",
      "/**",
      " * 初始state",
      " */",
      "const initialState = {",
      "  value,",
      "};",
      "",
      "export const ${1:name}Slice = createSlice({",
      "  name: \"${1:name}\",",
      "  initialState,",
      "  reducers: {",
      "    setValue(state,{payload}) {",
      "      ",
      "    }",
      "  },",
      "});",
      "// Action creators are generated for each case reducer function",
      "export const {",
      "  setValue",
      "} = ${1:name}Slice.actions;",
      "",
      "export default ${1:name}Slice.reducer;"
    ]
  },
  "redux_toolkit_store": {
    "prefix": [
      "!reduxStore"
    ],
    "description": "\nimport { configureStore } from '@reduxjs/toolkit';\n\nimport ${2:name}Reducer from './${2:name}Slice';\n\n\nexport const store = configureStore({\n  reducer: {\n    ${2:name}: ${2:name}Reducer,\n  },\n});\n\nglobalThis.$store = store;\n\n",
    "body": [
      "import { configureStore } from '@reduxjs/toolkit';",
      "",
      "import ${2:name}Reducer from './${2:name}Slice';",
      "",
      "",
      "export const store = configureStore({",
      "  reducer: {",
      "    ${2:name}: ${2:name}Reducer,",
      "  },",
      "});",
      "",
      "globalThis.$store = store;"
    ]
  },
  "snippet": {
    "prefix": [
      "!snippet"
    ],
    "description": "\nconst body = ``\nconst description = \"\";\n\nmodule.exports = {\n  prefix: [\"!snippet\"],\n  type: [\"javascript\"],\n  description: description || body,\n  body: body.trim(),\n};\n",
    "body": [
      "const body = ``",
      "const description = \"\";",
      "",
      "module.exports = {",
      "  prefix: [\"!snippet\"],",
      "  type: [\"javascript\"],",
      "  description: description || body,",
      "  body: body.trim(),",
      "};"
    ]
  },
  "state_action_function": {
    "prefix": [
      "state"
    ],
    "description": "\n(state, { payload }) => {\n  if (!payload) {\n    return;\n  }\n  state.${1:value} = payload;\n}\n\n",
    "body": [
      "(state, { payload }) => {",
      "  if (!payload) {",
      "    return;",
      "  }",
      "  state.${1:value} = payload;",
      "}"
    ]
  },
  "then_catch": {
    "prefix": [
      ".thencatch"
    ],
    "description": "\n.then(()=>{\n\n})\n.catch(()=>{})\n",
    "body": [
      ".then(()=>{",
      "",
      "})",
      ".catch(()=>{})"
    ]
  },
  "throttle": {
    "prefix": [
      "throttle"
    ],
    "description": "debounce 实现，虽然已经有 lodash 库 但是有时候不用 lodash",
    "body": [
      "function throttle(fn, delay=1000) {",
      "  let prevTime = 0",
      "  let timer",
      "  return function(...args) {",
      "    const now = Date.now()",
      "    const remaining = delay - (now - prevTime);",
      "    // 如果第二次执行超过delay了就立即执行",
      "    // remaining > wait是为了处理修改了系统时间的情况",
      "    // 比如把当前系统时间往过去调了十分钟，那么now其实是比prevTime小的",
      "    // 那么remaning就可能是一个比较大的数了",
      "    if (remaining > 0 || remaining > wait) {",
      "      if (timer) {",
      "        clearTimeout(timer)",
      "        timer = null",
      "      }",
      "      fn.apply(this, args)",
      "      prevTimer = now",
      "    } else if (!timer) {",
      "      // 这里就是为了处理1.5s停止触发的情况",
      "      // 以1.5s为例，delay为1s，这个时候我们设置一个定时器",
      "      // 让它在0.5s后执行",
      "      // 这样在整个过程中，就是第0s, 第1s，第2s分别执行一次，共三次",
      "      // 虽然我们是1.5s就停止触发了",
      "      // 这样就保证了最后一次动作一直可以执行",
      "      timer = setTimeout(() => {",
      "        fn.apply(this, args)",
      "        timer = null",
      "        prevTime = Date.now()",
      "      }, remaining)",
      "    }",
      "  }",
      "}"
    ]
  },
  "try_catch": {
    "prefix": [
      "trycc"
    ],
    "description": "try{\n  $1\n}catch(err){\n  $2\n}",
    "body": [
      "try{",
      "  $1",
      "}catch(err){",
      "  $2",
      "}"
    ]
  },
  "type_of": {
    "prefix": [
      "typeOf"
    ],
    "description": "检验数据类型",
    "body": [
      "function typeOf (value){",
      "  return Object.prototype.toString.call(value).slice(8,-1).toLowerCase()",
      "}"
    ]
  },
  "var_comment": {
    "prefix": [
      "!vh"
    ],
    "description": "\n/**\n * @var $1  \n * @desc $变量定义\n * @property {string} $2 $变量名\n * \n */\n",
    "body": [
      "/**",
      " * @var $1  ",
      " * @desc $变量定义",
      " * @property {string} $2 $变量名",
      " * ",
      " */"
    ]
  },
  "vue2_mixin": {
    "prefix": [
      "oef"
    ],
    "description": "export default {\n  // 组件名\n  components: {},\n  // filters:{},\n  // mixins:[],\n  // props: {},\n  // data(){\n  //   return{\n  //     \n  //   }\n  // },\n  // 组件方法\n  // computed:{},\n  // watch:{},\n  // mounted(){},\n  methods: {},\n}",
    "body": [
      "export default {",
      "  // 组件名",
      "  components: {},",
      "  // filters:{},",
      "  // mixins:[],",
      "  // props: {},",
      "  // data(){",
      "  //   return{",
      "  //     ",
      "  //   }",
      "  // },",
      "  // 组件方法",
      "  // computed:{},",
      "  // watch:{},",
      "  // mounted(){},",
      "  methods: {},",
      "}"
    ]
  },
  "writable": {
    "prefix": [
      "!writable"
    ],
    "description": "\nconst { Writable } = require(\"stream\");\n\n\nconst writableStream = new Writable({\n  write(chunk, encoding, callback) {\n    callback();\n  },\n});\n\n\n",
    "body": [
      "const { Writable } = require(\"stream\");",
      "",
      "",
      "const writableStream = new Writable({",
      "  write(chunk, encoding, callback) {",
      "    callback();",
      "  },",
      "});"
    ]
  },
  "zx": {
    "prefix": [
      "!zx"
    ],
    "description": "\n#!/usr/bin/env zx\n/**\n * 功能: $1\n * \n */ \nawait $``\n",
    "body": [
      "#!/usr/bin/env zx",
      "/**",
      " * 功能: $1",
      " * ",
      " */ ",
      "await $``"
    ]
  }
}